Caso de Prueba: caso01_declaraciones_tipos (Correcto)

Código :
let int contador;
let float radio;
let float area;
let string nombre;
let boolean activo;
contador = 100;
radio = 5.5;
area = 0.0;
nombre = 'Juan';
activo = true;

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<contador,1>
<puntoComa, ;>
<PRlet, let>
<PRfloat, float>
<radio,2>
<puntoComa, ;>
<PRlet, let>
<PRfloat, float>
<area,3>
<puntoComa, ;>
<PRlet, let>
<PRstring, string>
<nombre,4>
<puntoComa, ;>
<PRlet, let>
<PRboolean, boolean>
<activo,5>
<puntoComa, ;>
<contador,1>
<igual, =>
<entero, 100>
<puntoComa, ;>
<radio,2>
<igual, =>
<real, 5.5>
<puntoComa, ;>
<area,3>
<igual, =>
<real, 0.0>
<puntoComa, ;>
<nombre,4>
<igual, =>
<cadena, Juan>
<puntoComa, ;>
<activo,5>
<igual, =>
<true, true>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'contador'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'radio'
  TIPO: REAL
  DESPLAZAMIENTO: 2
------------------------------------------
LEXEMA: 'area'
  TIPO: REAL
  DESPLAZAMIENTO: 6
------------------------------------------
LEXEMA: 'nombre'
  TIPO: CADENA
  DESPLAZAMIENTO: 10
------------------------------------------
LEXEMA: 'activo'
  TIPO: BOOLEAN
  DESPLAZAMIENTO: 74
------------------------------------------

------------------------------
Reglas para VAST
descendente 1 2 5 9 2 5 10 2 5 10 2 5 12 2 5 11 2 8 44 49 51 22 25 28 33 30 27 24 2 8 44 49 51 22 25 28 34 30 27 24 2 8 44 49 51 22 25 28 34 30 27 24 2 8 44 49 51 22 25 28 35 30 27 24 2 8 44 49 51 22 25 28 36 30 27 24 4
------------------------------
Arbol generado



Caso de Prueba: caso02_funciones_nested (Correcto)

Código :
function int cuadrado(int n) {
    return n + n; // Imaginamos que es n*n, pero solo tenemos + y comparadores
}
let int lado;
let int resultado;
lado = 4;
resultado = cuadrado(lado);

------------------------------
Tokens
<PRfun, function>
<PRint, int>
<cuadrado,1>
<parenIzq, (>
<PRint, int>
<n,2>
<parenDcha, )>
<llaveIzq, {>
<PRreturn, return>
<n,2>
<opSuma, +>
<n,2>
<puntoComa, ;>
<llaveDcha, }>
<PRlet, let>
<PRint, int>
<lado,3>
<puntoComa, ;>
<PRlet, let>
<PRint, int>
<resultado,4>
<puntoComa, ;>
<lado,3>
<igual, =>
<entero, 4>
<puntoComa, ;>
<resultado,4>
<igual, =>
<cuadrado,1>
<parenIzq, (>
<lado,3>
<parenDcha, )>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'n'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'cuadrado'
  TIPO: FUNCION
  RETORNO: ENTERO
  NUM_PARAMS: 1
  TIPOS_PARAMS: [ENTERO]
------------------------------------------
LEXEMA: 'lado'
  TIPO: ENTERO
  DESPLAZAMIENTO: 2
------------------------------------------
LEXEMA: 'resultado'
  TIPO: ENTERO
  DESPLAZAMIENTO: 4
------------------------------------------

------------------------------
Reglas para VAST
descendente 1 3 13 9 18 9 21 56 16 48 53 22 25 28 31 39 29 31 39 30 27 24 2 5 9 2 5 9 2 8 44 49 51 22 25 28 33 30 27 24 2 8 44 49 51 22 25 28 31 38 40 22 25 28 31 39 30 27 24 43 30 27 24 4
------------------------------
Arbol generado



Caso de Prueba: caso03_bucle_for_infinito (Correcto)

Código :
let int i;
let int suma;
suma = 0;
// Bucle con condicion siempre true (valido semanticamente)
for (i = 0; true; i = i + 1) {
    suma = suma + i;
    if (i == 10) suma = 0;
}

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<i,1>
<puntoComa, ;>
<PRlet, let>
<PRint, int>
<suma,2>
<puntoComa, ;>
<suma,2>
<igual, =>
<entero, 0>
<puntoComa, ;>
<PRfor, for>
<parenIzq, (>
<i,1>
<igual, =>
<entero, 0>
<puntoComa, ;>
<true, true>
<puntoComa, ;>
<i,1>
<igual, =>
<i,1>
<opSuma, +>
<entero, 1>
<parenDcha, )>
<llaveIzq, {>
<suma,2>
<igual, =>
<suma,2>
<opSuma, +>
<i,1>
<puntoComa, ;>
<PRif, if>
<parenIzq, (>
<i,1>
<opIgual, ==>
<entero, 10>
<parenDcha, )>
<suma,2>
<igual, =>
<entero, 0>
<puntoComa, ;>
<llaveDcha, }>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'i'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'suma'
  TIPO: ENTERO
  DESPLAZAMIENTO: 2
------------------------------------------

------------------------------
Reglas para VAST
descendente 1 2 5 9 2 5 9 2 8 44 49 51 22 25 28 33 30 27 24 2 7 14 51 22 25 28 33 30 27 24 22 25 28 36 30 27 24 14 51 22 25 28 31 39 29 33 30 27 24 55 8 44 49 51 22 25 28 31 39 29 31 39 30 27 24 55 6 22 25 28 31 39 30 26 28 33 30 27 24 44 49 51 22 25 28 33 30 27 24 56 4
------------------------------
Arbol generado



Caso de Prueba: caso04_condicional_complejo (Correcto)

Código :
let int puntaje;
let boolean pasa;
puntaje = 60;
pasa = false;
// Usamos == y && que si estan soportados en lexico y gramatica
if (puntaje == 60 && true) pasa = true;

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<puntaje,1>
<puntoComa, ;>
<PRlet, let>
<PRboolean, boolean>
<pasa,2>
<puntoComa, ;>
<puntaje,1>
<igual, =>
<entero, 60>
<puntoComa, ;>
<pasa,2>
<igual, =>
<false, false>
<puntoComa, ;>
<PRif, if>
<parenIzq, (>
<puntaje,1>
<opIgual, ==>
<entero, 60>
<opAnd, &&>
<true, true>
<parenDcha, )>
<pasa,2>
<igual, =>
<true, true>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'puntaje'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'pasa'
  TIPO: BOOLEAN
  DESPLAZAMIENTO: 2
------------------------------------------

------------------------------
Reglas para VAST
descendente 1 2 5 9 2 5 11 2 8 44 49 51 22 25 28 33 30 27 24 2 8 44 49 51 22 25 28 37 30 27 24 2 6 22 25 28 31 39 30 26 28 33 30 27 23 25 28 36 30 27 24 44 49 51 22 25 28 36 30 27 24 4
------------------------------
Arbol generado



Caso de Prueba: caso05_operaciones_variadas (Correcto)

Código :
let float x;
let float y;
x = 10.0;
y = 2.0;
x /= 2.0;
// Solo tenemos + y /=
x = x + y;
x /= y;

------------------------------
Tokens
<PRlet, let>
<PRfloat, float>
<x,1>
<puntoComa, ;>
<PRlet, let>
<PRfloat, float>
<y,2>
<puntoComa, ;>
<x,1>
<igual, =>
<real, 10.0>
<puntoComa, ;>
<y,2>
<igual, =>
<real, 2.0>
<puntoComa, ;>
<x,1>
<asigDiv, /=>
<real, 2.0>
<puntoComa, ;>
<x,1>
<igual, =>
<x,1>
<opSuma, +>
<y,2>
<puntoComa, ;>
<x,1>
<asigDiv, /=>
<y,2>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'x'
  TIPO: REAL
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'y'
  TIPO: REAL
  DESPLAZAMIENTO: 4
------------------------------------------

------------------------------
Reglas para VAST
descendente 1 2 5 10 2 5 10 2 8 44 49 51 22 25 28 34 30 27 24 2 8 44 49 51 22 25 28 34 30 27 24 2 8 44 49 52 22 25 28 34 30 27 24 2 8 44 49 51 22 25 28 31 39 29 31 39 30 27 24 2 8 44 49 52 22 25 28 31 39 30 27 24 4
------------------------------
Arbol generado



Caso de Prueba: caso06_error_lexico_simbolos (Incorrecto)

Código :
let int usuario;
usuario = 1;
// @ y # no estan permitidos
if (usuario == 1) usuario = 2; @ 

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<usuario,1>
<puntoComa, ;>
<usuario,1>
<igual, =>
<entero, 1>
<puntoComa, ;>
<PRif, if>
<parenIzq, (>
<usuario,1>
<opIgual, ==>
<entero, 1>
<parenDcha, )>
<usuario,1>
<igual, =>
<entero, 2>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'usuario'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------

------------------------------
Errores Detectados
[ERROR LÉXICO - Línea 4]: Símbolo no reconocido: '@'

------------------------------
Arbol generado
(No se genera árbol debido a errores)
Caso de Prueba: caso07_error_sintactico_punto_coma (Incorrecto)

Código :
let string mensaje;
mensaje = 'Hola' // Falta punto y coma
let int largo;
largo = 4;

------------------------------
Tokens
<PRlet, let>
<PRstring, string>
<mensaje,1>
<puntoComa, ;>
<mensaje,1>
<igual, =>
<cadena, Hola>
<PRlet, let>
<PRint, int>
<largo,2>
<puntoComa, ;>
<largo,2>
<igual, =>
<entero, 4>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'mensaje'
  TIPO: CADENA
  DESPLAZAMIENTO: 0
------------------------------------------

------------------------------
Errores Detectados
[ERROR SINTÁCTICO - Línea 3]: Se esperaba ';'

------------------------------
Arbol generado
(No se genera árbol debido a errores)
Caso de Prueba: caso08_error_sintactico_parentesis (Incorrecto)

Código :
let int a;
a = 10;
// Falta parentesis de cierre
if (a == 10 a = 0;

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<a,1>
<puntoComa, ;>
<a,1>
<igual, =>
<entero, 10>
<puntoComa, ;>
<PRif, if>
<parenIzq, (>
<a,1>
<opIgual, ==>
<entero, 10>
<a,1>
<igual, =>
<entero, 0>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'a'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------

------------------------------
Errores Detectados
[ERROR SINTÁCTICO - Línea 4]: Se esperaba ')' tras la condición
[ERROR SINTÁCTICO - Línea 4]: Sentencia no válida

------------------------------
Arbol generado
(No se genera árbol debido a errores)
Caso de Prueba: caso09_error_semantico_tipos_incompatibles (Incorrecto)

Código :
let int edad;
let string texto;
edad = 25;
texto = 'Veinticinco';
edad = texto; // Error: asignar string a int

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<edad,1>
<puntoComa, ;>
<PRlet, let>
<PRstring, string>
<texto,2>
<puntoComa, ;>
<edad,1>
<igual, =>
<entero, 25>
<puntoComa, ;>
<texto,2>
<igual, =>
<cadena, Veinticinco>
<puntoComa, ;>
<edad,1>
<igual, =>
<texto,2>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'edad'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'texto'
  TIPO: CADENA
  DESPLAZAMIENTO: 2
------------------------------------------

------------------------------
Errores Detectados
[ERROR SEMÁNTICO - Línea 5]: Tipos incompatibles en asignación: ENTERO y CADENA

------------------------------
Arbol generado
(No se genera árbol debido a errores)
Caso de Prueba: caso10_error_semantico_no_declarada_y_params (Incorrecto)

Código :
let int x;
let int y;
x = 5;
y = 10;

function int doble(int n) {
    return n + n;
}
x = doble(true); // Parametro boolean en lugar de int
z = 5; // z no declarada

------------------------------
Tokens
<PRlet, let>
<PRint, int>
<x,1>
<puntoComa, ;>
<PRlet, let>
<PRint, int>
<y,2>
<puntoComa, ;>
<x,1>
<igual, =>
<entero, 5>
<puntoComa, ;>
<y,2>
<igual, =>
<entero, 10>
<puntoComa, ;>
<PRfun, function>
<PRint, int>
<doble,3>
<parenIzq, (>
<PRint, int>
<n,4>
<parenDcha, )>
<llaveIzq, {>
<PRreturn, return>
<n,4>
<opSuma, +>
<n,4>
<puntoComa, ;>
<llaveDcha, }>
<x,1>
<igual, =>
<doble,3>
<parenIzq, (>
<true, true>
<parenDcha, )>
<puntoComa, ;>
<z,5>
<igual, =>
<entero, 5>
<puntoComa, ;>
<finFich, >
------------------------------
tabla de simbolos
LEXEMA: 'n'
  TIPO: ENTERO
  DESPLAZAMIENTO: 4
------------------------------------------
LEXEMA: 'x'
  TIPO: ENTERO
  DESPLAZAMIENTO: 0
------------------------------------------
LEXEMA: 'y'
  TIPO: ENTERO
  DESPLAZAMIENTO: 2
------------------------------------------
LEXEMA: 'doble'
  TIPO: FUNCION
  RETORNO: ENTERO
  NUM_PARAMS: 1
  TIPOS_PARAMS: [ENTERO]
------------------------------------------

------------------------------
Errores Detectados
[ERROR SINTÁCTICO - Línea 9]: Parámetros incorrectos en llamada a función 'doble'
[ERROR SEMÁNTICO - Línea 9]: Tipos incompatibles en asignación: ENTERO y ERROR
[ERROR SEMÁNTICO - Línea 10]: 'z' no es una variable

------------------------------
Arbol generado
(No se genera árbol debido a errores)
