package lexico;

import java.util.*;

/**
 * Analizador léxico que devuelve tokens con tipos en texto
 * directamente alineados con la gramática del analizador sintáctico.
 */
public class Lexer {

    private final String input;                   // Código fuente de entrada
    private final List<Token> tokens = new ArrayList<>();  // Lista de tokens generados
    private final LinkedHashMap<String, Integer> symbolTable = new LinkedHashMap<>(); // Tabla de símbolos con posiciones
    private int pos = 0;                          // Posición actual en la cadena
    private int line = 1;                         // Línea actual
    private int column = 1;                       // Columna actual
    private int tokenStartColumn = 1;             // Columna donde comienza el token

    /** Palabras reservadas del lenguaje -> tipo de token resultante */
    private static final Map<String, String> keywords = new HashMap<>();

    static {
        keywords.put("boolean", "boolean");
        keywords.put("float", "float");
        keywords.put("for", "for");
        keywords.put("function", "function");
        keywords.put("if", "if");
        keywords.put("int", "int");
        keywords.put("let", "let");
        keywords.put("read", "read");
        keywords.put("return", "return");
        keywords.put("string", "string");
        keywords.put("void", "void");
        keywords.put("true", "true");
        keywords.put("false", "false");
        keywords.put("write", "write");
    }

    /**
     * Constructor del analizador léxico.
     * @param input texto fuente que se analizará.
     */
    public Lexer(String input) {
        this.input = input;
    }

    /**
     * Analiza todo el texto de entrada y genera los tokens correspondientes.
     * @return lista de tokens encontrados en el código fuente.
     */
    public List<Token> tokenize() {
        while (pos < input.length()) {
            char current = peek();

            if (current == '\n') {
                line++;
                column = 1;
                advance();
            } else if (Character.isWhitespace(current)) {
                advance();
            } else if (Character.isLetter(current) || current == '_') {
                tokenStartColumn = column;
                lexIdentifierOrKeyword();
            } else if (Character.isDigit(current)) {
                tokenStartColumn = column;
                lexNumber();
            } else {
                tokenStartColumn = column;
                switch (current) {
                    case '+':
                        advance();
                        if (match('+')) {
                            addToken("++", "++");
                        } else {
                            addToken("+", "+");
                        }
                        break;

                    case '=':
                        advance();
                        if (match('=')) addToken("==", "==");
                        else addToken("=", "=");
                        break;

                    case '&':
                        advance();
                        if (match('&')) addToken("&&", "&&");
                        else error("Símbolo no permitido '&'");
                        break;

					case '/':
						advance();
						if (match('=')) {
							addToken("/=", "/=");
						} else if (match('/')) {
							skipLineComment();  // Comentario de línea
						} else {
							error("Símbolo no permitido '/'");
						}
					break;


                    case ',':
                        advance(); addToken(",", ","); break;
                    case ';':
                        advance(); addToken(";", ";"); break;
                    case '(':
                        advance(); addToken("(", "("); break;
                    case ')':
                        advance(); addToken(")", ")"); break;
                    case '{':
                        advance(); addToken("{", "{"); break;
                    case '}':
                        advance(); addToken("}", "}"); break;
                    case '\'':
                        lexString();
                        break;
                    default:
                        error("Símbolo no reconocido: '" + current + "'");
                        advance();
                        break;
                }
            }
        }

        tokens.add(new Token("EOF", "", line, column, column, null));
        return tokens;
    }

    /**
     * Reconoce identificadores o palabras reservadas.
     * Si el lexema no está en las palabras clave, se agrega a la tabla de símbolos.
     */
    private void lexIdentifierOrKeyword() {
        int start = pos;
        while (pos < input.length() &&
                (Character.isLetterOrDigit(peek()) || peek() == '_')) {
            advance();
        }
        String lexeme = input.substring(start, pos);
        String type = keywords.getOrDefault(lexeme, "id");
        if ("id".equals(type)) {
            int position = symbolTable.computeIfAbsent(lexeme, key -> symbolTable.size() + 1);
            addToken(type, lexeme, position);
        } else {
            addToken(type, lexeme);
        }
    }

    /**
     * Reconoce números enteros y reales (con punto decimal).
     * @throws NumberFormatException si el formato es inválido.
     */
    private void lexNumber() {
        int start = pos;
        boolean isReal = false;

        while (pos < input.length() && Character.isDigit(peek())) advance();

        if (peek() == '.') {
            isReal = true;
            advance();
            while (pos < input.length() && Character.isDigit(peek())) advance();
        }

        String lexeme = input.substring(start, pos);
        try {
            if (isReal) {
                double value = Double.parseDouble(lexeme);
                if (value > 117549436.0) error("Número real demasiado grande: " + lexeme);
                else addToken("real", lexeme);
            } else {
                int value = Integer.parseInt(lexeme);
                if (value > 32767) error("Número entero demasiado grande: " + lexeme);
                else addToken("ent", lexeme);
            }
        } catch (NumberFormatException e) {
            error("Número inválido: " + lexeme);
        }
    }

    /**
     * Reconoce cadenas de texto delimitadas por comillas simples ('texto').
     * Genera error si la cadena no se cierra.
     */
    private void lexString() {
        advance(); // Salta la comilla inicial
        StringBuilder sb = new StringBuilder();

        while (pos < input.length() && peek() != '\'') {
            if (peek() == '\n') line++;
            sb.append(peek());
            advance();
        }

        if (peek() == '\'') {
            advance();
            addToken("cad", sb.toString());
        } else {
            error("Cadena no cerrada");
        }
    }

    /**
     * Omite comentarios de bloque del tipo /* ... *\/.
     * Los ignora completamente sin generar tokens.
     */
    private void skipComment() {
        advance(); // salta '*'
        while (pos < input.length()) {
            if (peek() == '*' && peek(1) == '/') {
                advance(); advance();
                break;
            }
            if (peek() == '\n') line++;
            advance();
        }
    }

    /**
     * Añade un nuevo token a la lista.
     * @param type tipo de token textual
     * @param lexeme texto original del token
     */
    private void addToken(String type, String lexeme) {
        addToken(type, lexeme, null);
    }

    /**
     * Añade un token permitiendo indicar la posición en la tabla de símbolos.
     */
    private void addToken(String type, String lexeme, Integer symbolIndex) {
        int endCol = tokenStartColumn + lexeme.length() - 1;
        tokens.add(new Token(type, lexeme, line, tokenStartColumn, endCol, symbolIndex));
    }

    /**
     * Muestra un mensaje de error léxico en consola.
     * @param msg descripción del error.
     */
    private void error(String msg) {
        System.err.println("[ERROR - Línea " + line + "]: " + msg);
    }

    /** @return carácter actual sin avanzar el cursor. */
    private char peek() {
        return pos < input.length() ? input.charAt(pos) : '\0';
    }

    /**
     * Lee un carácter adelantado sin mover la posición.
     * @param ahead cantidad de posiciones hacia adelante.
     * @return carácter leído o '\0' si está fuera de rango.
     */
    private char peek(int ahead) {
        return (pos + ahead) < input.length() ? input.charAt(pos + ahead) : '\0';
    }

    /** Avanza una posición en el texto fuente. */
    private void advance() {
        pos++;
        column++;
    }

    /**
     * Verifica si el siguiente carácter coincide con el esperado.
     * Si es así, avanza el cursor.
     * @param expected carácter esperado.
     * @return true si coincide, false si no.
     */
    private boolean match(char expected) {
        if (peek() == expected) {
            advance();
            return true;
        }
        return false;
    }

    /** @return tabla de símbolos generada durante el análisis. */
    public Map<String, Integer> getSymbolTable() {
        return symbolTable;
    }

    /** @return representación en texto de la tabla de símbolos. */
    public String printSymbolTable() {
        StringBuilder sb = new StringBuilder();
        sb.append("Tabla de Símbolos:\n");
        for (Map.Entry<String, Integer> entry : symbolTable.entrySet()) {
            sb.append(entry.getKey()).append("|").append(entry.getValue()).append("\n");
        }
        return sb.toString();
    }

	/**
	 * Omite comentarios de línea del tipo // hasta el salto de línea o EOF.
	 */
	private void skipLineComment() {
		while (pos < input.length() && peek() != '\n') {
			advance();
		}
	}

}
package lexico;

/**
 * Representa un token léxico con su tipo textual, lexema y ubicación.
 */
public class Token {
    private final String type;
    private final String lexeme;
    private final Integer symbolIndex; // opcional, solo para ids
    private final int line;
    private final int colStart;
    private final int colEnd;

    /**
     * @param type tipo lógico del token (por ejemplo "id", "int", "&&", "return"...)
     * @param lexeme texto asociado al token
     * @param line línea donde se encontró
     * @param colStart columna inicial
     * @param colEnd columna final
     * @param symbolIndex posición del lexema en la tabla de símbolos (solo para ids, puede ser null)
     */
    public Token(String type, String lexeme, int line, int colStart, int colEnd, Integer symbolIndex) {
        this.type = type;
        this.lexeme = lexeme;
        this.symbolIndex = symbolIndex;
        this.line = line;
        this.colStart = colStart;
        this.colEnd = colEnd;
    }

    public String getType() {
        return type;
    }

    public String getLexeme() {
        return lexeme;
    }

    public int getLine() {
        return line;
    }

    public int getColStart() {
        return colStart;
    }

    public int getColEnd() {
        return colEnd;
    }

    public boolean isType(String expected) {
        return type.equals(expected);
    }

    @Override
    public String toString() {
        if ("id".equals(type) && symbolIndex != null) {
            return "<" + lexeme + "," + symbolIndex + ">";
        }
        return "<" + type + ", " + lexeme + ">";
    }
}
package lexico;

import java.io.*;
import java.nio.file.*;
import java.util.List;

/**
 * Programa principal del Procesador de Lenguajes - Analizador Léxico.
 * 
 * Lee un fichero fuente, ejecuta el analizador léxico y genera:
 *  - tokens.txt: lista de tokens reconocidos
 *  - tabla_simbolos.txt: volcado de la tabla de símbolos
 *  - errores.txt: listado de errores léxicos detectados
 *
 * @author Grupo 15
 * @version Curso 2025/2026
 */
public class Main {

    public static void main(String[] args) {
        // Base del paquete "lexico" dentro de src para fuentes y salidas
        Path baseDir = Paths.get("src", "lexico");
        Path inputFile = baseDir.resolve("programa.javascript");
        Path outputDir = baseDir.resolve("out");

        // Crear carpeta de salida si no existe
        try {
            Files.createDirectories(outputDir);
        } catch (IOException e) {
            System.err.println("Error creando carpeta de salida: " + e.getMessage());
            return;
        }

        // Leer el archivo fuente
        String source;
        try {
            source = Files.readString(inputFile);
        } catch (IOException e) {
            System.err.println("No se pudo leer el archivo fuente: " + inputFile);
            return;
        }

        // Ejecutar el analizador léxico
        Lexer lexer = new Lexer(source);

        // Guardar errores en un buffer en lugar de imprimirlos directamente
        PrintStream originalErr = System.err;
        ByteArrayOutputStream errorStream = new ByteArrayOutputStream();
        System.setErr(new PrintStream(errorStream));

        List<Token> tokens = lexer.tokenize();

        // Restaurar la salida de error original
        System.setErr(originalErr);

        // Guardar tokens en archivo
        try (BufferedWriter writer = Files.newBufferedWriter(outputDir.resolve("tokens.txt"))) {
            for (Token token : tokens) {
                writer.write(token.toString());
                writer.newLine();
            }
        } catch (IOException e) {
            System.err.println("Error escribiendo tokens.txt: " + e.getMessage());
        }

        // Guardar tabla de símbolos
        try (BufferedWriter writer = Files.newBufferedWriter(outputDir.resolve("tabla_simbolos.txt"))) {
            writer.write(lexer.printSymbolTable());
        } catch (IOException e) {
            System.err.println("Error escribiendo tabla_simbolos.txt: " + e.getMessage());
        }

        // Guardar errores (si los hay)
        String errores = errorStream.toString().trim();
        try (BufferedWriter writer = Files.newBufferedWriter(outputDir.resolve("errores.txt"))) {
            if (errores.isEmpty()) {
                writer.write("Sin errores léxicos detectados.\n");
            } else {
                writer.write(errores);
                writer.newLine();
            }
        } catch (IOException e) {
            System.err.println("Error escribiendo errores.txt: " + e.getMessage());
        }

        System.out.println("Análisis léxico completado.\nResultados generados en la carpeta: " + outputDir);
    }
}
